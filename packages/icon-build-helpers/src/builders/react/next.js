/**
 * Copyright IBM Corp. 2019, 2019
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */

'use strict';

const { babel } = require('@rollup/plugin-babel');
const { camelCase } = require('change-case');
const fs = require('fs-extra');
const path = require('path');
const { rollup } = require('rollup');
const virtual = require('../plugins/virtual');

const BANNER = `/**
 * Copyright IBM Corp. 2016, 2021
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * Code generated by @carbon/icon-build-helpers. DO NOT EDIT.
 */`;
const external = ['@carbon/icon-helpers', 'react', 'prop-types'];
const babelConfig = {
  babelrc: false,
  exclude: /node_modules/,
  presets: [
    [
      '@babel/preset-env',
      {
        targets: {
          browsers: ['extends browserslist-config-carbon'],
        },
      },
    ],
    '@babel/preset-react',
  ],
  plugins: [
    '@babel/plugin-transform-react-constant-elements',
    'babel-plugin-dev-expression',
  ],
  babelHelpers: 'bundled',
};

async function builder(metadata, { output }) {
  const modules = metadata.icons.map((icon) => {
    const { component } = icon;
    return {
      filepath: component.filepath,
      moduleName: component.name,
      entrypoint: createIconEntrypoint(
        component.name,
        component.sizes,
        icon.deprecated
      ),
    };
  });

  const files = {
    'index.js': `${BANNER}\n\nexport { default as Icon } from './Icon.js';`,
  };
  const input = {
    'index.js': 'index.js',
  };

  for (const m of modules) {
    files[m.filepath] = m.entrypoint;
    input[m.filepath] = m.filepath;
  }

  const bundle = await rollup({
    input,
    external,
    plugins: [
      virtual({
        './Icon.js': await fs.readFile(
          path.resolve(__dirname, './components/Icon.js'),
          'utf8'
        ),
        ...files,
      }),
      babel(babelConfig),
    ],
  });

  await bundle.write({
    dir: path.join(output, 'next'),
    format: 'esm',
    entryFileNames: '[name]',
    banner: BANNER,
    exports: 'auto',
  });
}

function createIconEntrypoint(moduleName, sizes, isDeprecated = false) {
  const deprecatedPreamble = isDeprecated
    ? 'let didWarnAboutDeprecation = false;'
    : '';
  const deprecatedBlock = isDeprecated
    ? `
    if (__DEV__) {
      if (!didWarnAboutDeprecation) {
        didWarnAboutDeprecation = true;
        console.warn(
          \`The ${moduleName} component has been deprecated and will be \` +
          \`removed in the next major version of @carbon/icons-react.\`
        );
      }
    }
    `
    : '';
  const source = createIconSource(moduleName, sizes, deprecatedBlock);
  return `${BANNER}
import React from 'react';
import Icon from './Icon.js';
${deprecatedPreamble}
${source}
export default ${moduleName};
`;
}

/**
 * Generate an icon component, which in our case is the string representation
 * of the component, from a given moduleName and icon descriptor.
 * @param {string} moduleName
 * @param {object} descriptor
 * @param {string} customBlock
 */
function createIconSource(moduleName, sizes, customBlock = '') {
  if (sizes.length === 1) {
    const { size, ast } = sizes[0];
    const { props, children } = jsx(ast);
    return `
      const ${moduleName} = /*#__PURE__*/ React.forwardRef(
        function ${moduleName}({ children, size = ${size}, ...rest }, ref) {
          ${customBlock}
          return (
            <Icon
              width={size}
              height={size}
              ${formatAttributes(props)}
              ref={ref}
              {...rest}>
              ${children}
              {children}
            </Icon>
          );
        }
      );
    `;
  }

  const data = {};

  for (const { size, ast } of sizes) {
    data[size] = jsx(ast);
  }

  return `
    const paths = ${JSON.stringify(data)};
    const ${moduleName} = /*#__PURE__*/ React.forwardRef(
      function ${moduleName}({ children, size = 32, ...rest }, ref) {
        ${customBlock}
        const content = paths[size] || paths[32];
        return (
          <Icon
            width={size}
            height={size}
            {...content.props}
            ref={ref}
            {...rest}>
            {content.children}
            {children}
          </Icon>
        );
      }
    );
  `;
}

function jsx(node) {
  if (node.type === 'root') {
    return jsx(node.children[0]);
  }

  if (node.type === 'element') {
    if (node.tagName === 'svg') {
      return {
        props: node.properties,
        children: node.children.map(jsx),
      };
    }

    const { tagName: t, properties } = node;

    if (node.children.length > 0) {
      const children = node.children.map(jsx);
      return `<${t} ${formatAttributes(properties)}>${children}</${t}>`;
    }

    return `<${t} ${formatAttributes(properties)} />`;
  }

  throw new Error(`Unknown node type: ${node.type}`);
}

const attributeDenylist = ['data', 'aria'];

/**
 * Determine if the given attribute should be transformed when being converted
 * to a React prop or if we should pass it through as-is
 * @param {string} attribute
 * @returns {boolean}
 */
function shouldTransformAttribute(attribute) {
  return attributeDenylist.every((prefix) => !attribute.startsWith(prefix));
}

/**
 * Serialize a given object of key, value pairs to an JSX-compatible string
 * @param {object} attrs
 * @returns {string}
 */
function formatAttributes(attrs) {
  return Object.keys(attrs).reduce((acc, key, index) => {
    const attribute = shouldTransformAttribute(key)
      ? `${camelCase(key)}="${attrs[key]}"`
      : `${key}="${attrs[key]}"`;

    if (index === 0) {
      return attribute;
    }
    return acc + ' ' + attribute;
  }, '');
}

module.exports = builder;
